@using System.Text.Json
@using System.Text

<div class="row">
    <div class="col-md-8">
        <table class="table">
            <thead>
                <tr>
                    <th>Character</th>
                    <th>Type</th>
                    <th></th>
                </tr>
            </thead>
            <tbody>
                @foreach(var character in AvailableCharacters)
                {
                    <tr>
                        <td>@character.CharacterName</td>
                        <td>Player Character</td>
                        <td>
                            <button class="btn btn-danger" onclick="@(() => DeleteCharacter(character.CharacterName))">Delete</button>
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
    <div class="col-md-4">
        Import Characters
        <br />
        <InputFile accept="json" OnChange="Import" />
        <br />
        <br />
        <button class="btn btn-primary" onclick="@Export">Export Characters</button>
        <br />
        <br />
        <button class="btn btn-danger" onclick="@Clear">Delete All Characters</button>
    </div>
</div>

@code
{
    [Inject] public required StorageService Storage { get; set; }
    [Inject] public required IJSRuntime Js { get; set; }
    [Parameter, EditorRequired] public List<CharacterModel> AvailableCharacters { get; set; }


    public async Task Import(InputFileChangeEventArgs e)
    {
        using var stream = e.File.OpenReadStream();
        var json = await new StreamReader(stream).ReadToEndAsync();
        var importedCharacters = JsonSerializer.Deserialize<List<CharacterModel>>(json);
        if(importedCharacters is null || importedCharacters.Count == 0)
        {
            return;
        }
        var existingCharacters = await Storage.GetFromLocalStorage("Characters");
        if(existingCharacters is null or "[]")
        {
            await Storage.SetToLocalStorage("Characters", json);
            return;
        }
        var existingCharacterList = JsonSerializer.Deserialize<List<CharacterModel>>(existingCharacters);
        if(existingCharacterList is null)
        {
            await Storage.SetToLocalStorage("Characters", json);
            return;
        }
        existingCharacterList.AddRange(importedCharacters);
        var mergedJson = JsonSerializer.Serialize(existingCharacterList);
        await Storage.SetToLocalStorage("Characters", mergedJson);
        AvailableCharacters = existingCharacterList;
        StateHasChanged();
    }

    public async Task Export()
    {
        var existingCharacters = await Storage.GetFromLocalStorage("Characters");
        if(existingCharacters is null)
        {
            return;
        }
        var fileStream = new MemoryStream(new UTF8Encoding(true).GetBytes(existingCharacters));
        using var streamRef = new DotNetStreamReference(stream: fileStream);
        await Js.InvokeVoidAsync("downloadFileFromStream", "swrpgcharacters.json", streamRef);
    }

    public async Task Clear()
    {
        await Storage.RemoveFromLocalStorage("Characters");
    }

    public async Task DeleteCharacter(string characterName)
    {
        var characterToRemove = AvailableCharacters.FirstOrDefault(c => c.CharacterName == characterName);
        if(characterToRemove is null)
        {
            return;
        }
        AvailableCharacters.Remove(characterToRemove);
        var updatedJson = JsonSerializer.Serialize(AvailableCharacters);
        await Storage.SetToLocalStorage("Characters", updatedJson);
        StateHasChanged();
    }
}
