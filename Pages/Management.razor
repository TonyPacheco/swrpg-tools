@page "/mgmt"
@using System.Text.Json
@using System.Text

<MudGrid>
    <MudItem xs="12" md="8">
        <MudSimpleTable class="table">
            <thead>
                <tr>
                    <th>Character</th>
                    <th>Type</th>
                    <th></th>
                </tr>
            </thead>
            <tbody>
                @foreach(var character in Characters)
                {
                    <tr>
                        <td>@character.CharacterName</td>
                        <td>Player Character</td>
                        <td>
                            <MudButton onclick="@(() => DeleteCharacter(character.CharacterName))"
                                       Color="Color.Error"
                                       StartIcon="@Icons.Material.Filled.Delete" />
                        </td>
                    </tr>
                }
            </tbody>
        </MudSimpleTable>
    </MudItem>
    <MudItem sm="12" md="4">
        <MudStack>
            <MudFileUpload T="IBrowserFile" accept="json" OnFilesChanged="Import">
                <ActivatorContent>
                    <MudButton Variant="Variant.Outlined" StartIcon="@Icons.Material.Filled.Upload">
                        Import Characters
                    </MudButton>
                </ActivatorContent>
            </MudFileUpload>
            <MudButton Variant="Variant.Outlined" onclick="@Export" StartIcon="@Icons.Material.Filled.FileDownload">
                Export Characters
            </MudButton>
            <MudButton Variant="Variant.Outlined" Color="Color.Error" onclick="@Clear" StartIcon="@Icons.Material.Filled.Delete">
                Clear Characters
            </MudButton>
        </MudStack>
    </MudItem>
</MudGrid>

@code
{
    [Inject] public required StorageService Storage { get; set; }
    [Inject] public required IJSRuntime Js { get; set; }
    public List<CharacterModel> Characters { get; set; } = [];

    protected override async Task OnInitializedAsync()
    {
        Characters = (await Storage.GetFromLocalStorage<List<CharacterModel>>("Characters")) ?? [];
    }

    public async Task Import(InputFileChangeEventArgs e)
    {
        using var stream = e.File.OpenReadStream();
        var json = await new StreamReader(stream).ReadToEndAsync();
        var importedCharacters = JsonSerializer.Deserialize<List<CharacterModel>>(json);
        if(importedCharacters is null || importedCharacters.Count == 0)
        {
            return;
        }
        var existingCharacters = await Storage.GetFromLocalStorage<List<CharacterModel>>("Characters") ?? [];
        existingCharacters.AddRange(importedCharacters);
        await Storage.SetToLocalStorage("Characters", existingCharacters);
        Characters = existingCharacters;
        StateHasChanged();
    }

    public async Task Export()
    {
        var existingCharacters = await Storage.GetFromLocalStorage("Characters");
        if(existingCharacters is null)
        {
            return;
        }
        var fileStream = new MemoryStream(new UTF8Encoding(true).GetBytes(existingCharacters));
        using var streamRef = new DotNetStreamReference(stream: fileStream);
        await Js.InvokeVoidAsync("downloadFileFromStream", "swrpgcharacters.json", streamRef);
    }

    public async Task Clear()
    {
        await Storage.RemoveFromLocalStorage("Characters");
        Characters.Clear();
        StateHasChanged();
    }

    public async Task DeleteCharacter(string characterName)
    {
        var characterToRemove = Characters.FirstOrDefault(c => c.CharacterName == characterName);
        if(characterToRemove is null)
        {
            return;
        }
        Characters.Remove(characterToRemove);
        await Storage.SetToLocalStorage("Characters", Characters);
        StateHasChanged();
    }
}
